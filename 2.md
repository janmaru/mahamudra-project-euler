# Even Fibonacci numbers #
## Problem 2 ##

Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.

[This problem is part of a project called Project Euler, that you can find here.](https://projecteuler.net/problem=2 "project euler")

First af all we start with the definition of Fibonacci numbers:

>By definition, the first two numbers in the Fibonacci sequence are either 1 and 1, 
>or 0 and 1, depending on the chosen starting point of the sequence, and each subsequent number
>is the sum of the previous two. (wiki)

hence the recursive function:

        let rec fib n:BigInteger  = 
            match n with 
                | 0 -> 0I 
                | 1 -> 1I 
                | _ -> fib (n - 1) + fib (n - 2)

of course this is a naive implementation a takes  Fib(N) = (1/sqrt(5)) * 1.618^(N+1) (approximately) time execution 

so we can print the first N fibonacci numbers:

        //first n=10 fibonacci numbers starting from 2
        printfn "%A" ({2..11}|>Seq.map (fun x-> fib x))
        //[1; 2; 3; 5; 8; 13; 21; 34; 55; 89]


then we define a function that sorts the odds:

        let even_II n:BigInteger =
            match n with
            | n when n%2I = 0I -> n 
            |_ -> 0I


then we need an infinite sequence that stops scanning before 4*10^6:

        // Seq.initInfinite  generates a new sequence which, when iterated, will return successive 
        // elements by calling the given function.

        let seqInfinite = Seq.initInfinite (fun index->
             let fb = fib index
             if fb <= 3999999I then
                printfn "%A" fb
                fb
             else
                -1I)

but this sequence will continue to evaluate after 4*10^6 giving out -1, so we need to "stop" it.

        // Returns a sequence that, when iterated, yields elements of the underlying sequence while 
        // the given predicate returns true, and then returns no further elements.

        let filteredSeqInfinite = Seq.takeWhile (fun elem -> elem >= 0I) seqInfinite

then at last, our solution:



        let sumEvenFibsBefore4Millions = 
                    filteredSeqInfinite 
                        |> Seq.map (fun x -> even_II x) 
                        |> Seq.sum

        let sumEvenFibsBefore4Millions_II = 
                    filteredSeqInfinite 
                        |> Seq.where(fun x -> x%2I=0I) 
                        |> Seq.sum

Could we do better? Maybe in less functional style?

        // it would be nice if starting from 1 and 2 we could evaluate
        // the oddity of the sum of the previous and actual number 
        // until we get to 4.000.000 and sum it up

        let mutable prev = 1I
        let mutable actual = 1I

        let seqInfiniteEvens = 
            Seq.initInfinite (fun index -> 
                let temp = actual
                actual <- prev + actual
                prev <- temp
                if actual <= 3999999I then 
                    if actual % 2I = 0I then actual
                    else 0I
                else -1I)

        let sumFiniteEvens = Seq.takeWhile (fun elem -> elem >= 0I) seqInfiniteEvens  |> Seq.sum 