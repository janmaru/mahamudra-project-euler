// In mathematics, the Fibonacci numbers or Fibonacci sequence are the numbers 
// in the following integer sequence: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

// By definition, the first two numbers in the Fibonacci sequence are either 1 and 1, 
// or 0 and 1, depending on the chosen starting point of the sequence, and each subsequent number
// is the sum of the previous two.

// Problem 2
// Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:

// 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

// By considering the terms in the Fibonacci sequence whose values do not exceed four million, 
// find the sum of the even-valued terms.

// Today we're going to use Seq and the reasons are:

// When interacting with other .NET languages or libraries that require IEnumerable<T>.
// Need to represent an infinite sequence.
// Need lazy evaluation.
// When you don't want to hold all elements in memory at the same time.
// When you are not concatenating (repeated Seq.append will stack overflow).


// 1.
//------------ Fib(N) = (1/sqrt(5)) * 1.618^(N+1) (approximately) time execution 
// with recursive naive function

//We define first an even function

open System.Numerics

let even n =
    match n with
    | n when n%2 = 0 -> true
    |_ -> false

let even_II n:BigInteger =
    match n with
    | n when n%2I = 0I -> n 
    |_ -> 0I

//We could also define an odd function
let odd n =
    if (n%2=0) then
       false
    else
       true

// based on the definition of fibonacci number we could use a recursive function
// to calculate the n-th fibonacci number
let rec fib n:BigInteger  = 
    match n with 
        | 0 -> 0I 
        | 1 -> 1I 
        | _ -> fib (n - 1) + fib (n - 2)

//first n=10 fibonacci numbers
printfn "%A" ([1..10]|>List.map (fun x-> fib x))
//[1; 1; 2; 3; 5; 8; 13; 21; 34; 55]

//first n=10 fibonacci numbers starting from 2
printfn "%A" ({2..11}|>Seq.map (fun x-> fib x))
//[1; 2; 3; 5; 8; 13; 21; 34; 55; 89]

// actually we don't know in advance the n in the fib n so that fib n < 4*10**6-1
// we could use an infinite sequence starting from 2 and selecting all the even values
// then adding them up

// Seq.initInfinite  generates a new sequence which, when iterated, will return successive 
// elements by calling the given function.

let seqInfinite = Seq.initInfinite (fun index->
     let fb = fib index
     if fb <= 3999999I then
        printfn "%A" fb
        fb
     else
        -1I)
//0
//1
//1
//2
//3
//5
//8
//13
//21
//34
//55
//89
//144
//233
//377
//610
//987
//1597
//2584
//4181
//6765
//10946
//17711
//28657
//46368
//75025
//121393
//196418
//317811
//514229
//832040
//1346269
//2178309
//3524578

printfn "%A" seqInfinite
//seq [0; 1; 1; 2; ...]

// Returns a sequence that, when iterated, yields elements of the underlying sequence while 
// the given predicate returns true, and then returns no further elements.

let filteredSeqInfinite = Seq.takeWhile (fun elem -> elem >= 0I) seqInfinite

let sumEvenFibsBefore4Millions = 
            filteredSeqInfinite 
                |> Seq.map (fun x -> even_II x) 
                |> Seq.sum

let sumEvenFibsBefore4Millions_II = 
            filteredSeqInfinite 
                |> Seq.where(fun x -> x%2I=0I) 
                |> Seq.sum

let result = sumEvenFibsBefore4Millions 

printfn "sumEvenFibsBefore4Millions: %A" result

printfn "sumEvenFibsBefore4Millions_II: %A" sumEvenFibsBefore4Millions_II

// the problem with this approach is that Seq.initInfinite calls the fib function
// every time so it has to re-calculate the fibs at every loop


// 2.
// it would be nice if starting from 1 and 2 we could evaluate
// the oddity of the sum of the previous and actual number 
// until we get to 4.000.000 and sum it up

let mutable prev = 1I
let mutable actual = 1I

let seqInfiniteEvens = 
    Seq.initInfinite (fun index -> 
        let temp = actual
        actual <- prev + actual
        prev <- temp
        if actual <= 3999999I then 
            if actual % 2I = 0I then actual
            else 0I
        else -1I)

let sumFiniteEvens = Seq.takeWhile (fun elem -> elem >= 0I) seqInfiniteEvens  |> Seq.sum 

printfn "sumFiniteEvens: %A" sumFiniteEvens
 
// 3.
// thanx Tomas Petricek for giving out the following solution in order to enumerate all the fibonacci
// numbers below K (in this case 4000000)

// Recursive function that implements the looping
// (it takes previous two elements, a and b)
let rec fibsRec a b limit =
  if a + b < limit then
    // The current element
    let current = a + b
    // Calculate all remaining elements recursively 
    // using 'b' as 'a' and 'current' as 'b' (in the next iteration)
    let rest = fibsRec b current limit
    // Return the remaining elements with 'current' appended to the 
    // front of the resulting list (this constructs new list, 
    // so there is no mutation here!)
    current::rest
  else 
    [] // generated all elements - return empty list once we're done

// generate list with 1, 2 and all other larger fibonaccis blow 4000000
let fibs = 1::2::(fibsRec 1 2 4000000)
//  [1; 2; 3; 5; 8; 13; 21; 34; 55; 89; 144; 233; 377; 610; 987; 1597; 2584;
//   4181; 6765; 10946; 17711; 28657; 46368; 75025; 121393; 196418; 317811;
//   514229; 832040; 1346269; 2178309; 3524578]

let resultFib = fibs |> List.where(fun x -> x%2=0)|> List.sum

printfn "sumFiniteEvens: %A" (resultFib)
